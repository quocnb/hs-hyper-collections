type: edu
files:
  - name: src/collections/Main.java
    visible: true
    text: |-
      package collections;
      
      public class Main {
        public static void main(String[] args) {
          System.out.println("Hello World!");
        }
      }
    learner_created: false
  - name: test/ActualRange.java
    visible: false
    text: |
      import java.util.Objects;
      
      import static java.util.Objects.requireNonNull;
      
      class ActualRange<C extends Comparable> {
        private final C upperBound;
        private final C lowerBound;
        private final boolean upperBoundOpen;
        private final boolean lowerBoundOpen;
      
        private ActualRange(C lower, C upper, boolean lowerOpen, boolean upperOpen) {
          upperBound = upper;
          lowerBound = lower;
          upperBoundOpen = upperOpen;
          lowerBoundOpen = lowerOpen;
          if (lower != null && upper != null) {
            if (lower.compareTo(upper) > 0) {
              throw new IllegalArgumentException();
            }
            if (upperOpen && lowerOpen && Objects.equals(upperBound, lowerBound)) {
              throw new IllegalArgumentException();
            }
          }
        }
      
        public C getLowerBound(){
          return lowerBound;
        }
        public C getUpperBound(){
          return upperBound;
        }
      
        public static <C extends Comparable> ActualRange<C> open(C lower, C upper) {
          if (lower == null || upper == null) throw new NullPointerException();
          return new ActualRange<>(lower, upper, true, true);
        }
      
        public static <C extends Comparable> ActualRange<C> closed(C lower, C upper) {
          if (lower == null || upper == null) throw new NullPointerException();
          return new ActualRange<>(lower, upper, false, false);
        }
      
        public static <C extends Comparable> ActualRange<C> openClosed(C lower, C upper) {
          if (lower == null || upper == null) throw new NullPointerException();
          return new ActualRange<>(lower, upper, true, false);
        }
      
        public static <C extends Comparable> ActualRange<C> closedOpen(C lower, C upper) {
          if (lower == null || upper == null) throw new NullPointerException();
          return new ActualRange<>(lower, upper, false, true);
        }
      
        public static <C extends Comparable> ActualRange<C> greaterThan(C lower) {
          if (lower == null) throw new NullPointerException();
          return new ActualRange<>(lower, null, true, true);
        }
      
        public static <C extends Comparable> ActualRange<C> atLeast(C lower) {
          if (lower == null) throw new NullPointerException();
          return new ActualRange<>(lower, null, false, true);
        }
      
        public static <C extends Comparable> ActualRange<C> lessThan(C upper) {
          if (upper == null) throw new NullPointerException();
          return new ActualRange<>(null, upper, true, true);
        }
      
        public static <C extends Comparable> ActualRange<C> atMost(C upper) {
          if (upper == null) throw new NullPointerException();
          return new ActualRange<>(null, upper, true, false);
        }
      
        public static ActualRange all() {
          return new ActualRange<>(null, null, true, true);
        }
      
        public boolean contains(C value) {
          requireNonNull(value);
          return (lowerBound == null || (lowerBound.compareTo(value) < 0) || (lowerBound.compareTo(value) <= 0 && !lowerBoundOpen))
                  && (upperBound == null || (upperBound.compareTo(value) > 0) || (upperBound.compareTo(value) >= 0 && !upperBoundOpen));
      
        }
      
        public boolean encloses(ActualRange<C> other) {
          requireNonNull(other);
      
          if (isEmpty()) return false;
          if (other.isEmpty()) return true;
      
          boolean upper = other.upperBound != null
                  && (contains(other.upperBound) || (other.upperBound == upperBound && upperBoundOpen && other.upperBoundOpen)) ||
                  other.upperBound == null && upperBound == null;
          boolean lower = other.lowerBound != null
                  && (contains(other.lowerBound) || (other.lowerBound == lowerBound && lowerBoundOpen && other.lowerBoundOpen)) ||
                  other.lowerBound == null && lowerBound == null;
      
          return upper && lower;
        }
      
        public ActualRange<C> span(ActualRange<C> other) {
          if (other == null) throw new NullPointerException();
          if (isEmpty()) return other;
          if (other.isEmpty()) return this;
          C upper;
          boolean upperOpen;
          if (upperBound == null || other.upperBound == null) {
            upper = null;
            upperOpen = true;
      
          } else if (upperBound.compareTo(other.upperBound) > 0) {
            upper = upperBound;
            upperOpen = upperBoundOpen;
          } else if (upperBound.compareTo(other.upperBound) < 0) {
            upper = other.upperBound;
            upperOpen = other.upperBoundOpen;
          } else {
            upper = upperBound;
            upperOpen = upperBoundOpen && other.upperBoundOpen;
          }
          C lower;
          boolean lowerOpen;
          if (lowerBound == null || other.lowerBound == null) {
            lower = null;
            lowerOpen = true;
          } else if (lowerBound.compareTo(other.lowerBound) < 0) {
            lower = lowerBound;
            lowerOpen = lowerBoundOpen;
          } else if (lowerBound.compareTo(other.lowerBound) > 0) {
            lower = other.lowerBound;
            lowerOpen = other.lowerBoundOpen;
          } else {
            lower = lowerBound;
            lowerOpen = lowerBoundOpen && other.lowerBoundOpen;
          }
          return new ActualRange<>(lower, upper, lowerOpen, upperOpen);
        }
      
        public ActualRange<C> intersection(ActualRange<C> other) {
          if (isEmpty()) return this;
          if (other.isEmpty()) return other;
          if (other == null) throw new NullPointerException();
      
      
          C upper;
          boolean upperOpen;
          if (upperBound == null) {
            upper = other.upperBound;
            upperOpen = other.upperBoundOpen;
      
          } else if (other.upperBound == null) {
            upper = upperBound;
            upperOpen = upperBoundOpen;
          } else if (upperBound.compareTo(other.upperBound) > 0) {
            upper = other.upperBound;
            upperOpen = other.upperBoundOpen;
          } else if (upperBound.compareTo(other.upperBound) < 0) {
            upper = upperBound;
            upperOpen = upperBoundOpen;
          } else {
            upper = upperBound;
            upperOpen = upperBoundOpen || other.upperBoundOpen;
          }
      
          C lower;
          boolean lowerOpen;
          if (lowerBound == null) {
            lower = other.lowerBound;
            lowerOpen = other.lowerBoundOpen;
      
          } else if (other.lowerBound == null) {
            lower = lowerBound;
            lowerOpen = lowerBoundOpen;
          } else if (lowerBound.compareTo(other.lowerBound) < 0) {
            lower = other.lowerBound;
            lowerOpen = other.lowerBoundOpen;
          } else if (lowerBound.compareTo(other.lowerBound) > 0) {
            lower = lowerBound;
            lowerOpen = lowerBoundOpen;
          } else {
            lower = lowerBound;
            lowerOpen = lowerBoundOpen || other.lowerBoundOpen;
          }
          if (lower == null || upper == null) {
            return new ActualRange<>(lower, upper, lowerOpen, upperOpen);
          }
          if (lower.compareTo(upper) > 0 || (lower.compareTo(upper) == 0 && lowerOpen && upperOpen)) {
            return new ActualRange<>(upper, upper, true, false);
          }
          return new ActualRange<>(lower, upper, lowerOpen, upperOpen);
        }
      
        public boolean isEmpty() {
          return lowerBound != null && lowerBoundOpen != upperBoundOpen && Objects.equals(lowerBound, upperBound);
        }
      
      
        @Override
        public String toString() {
          if (isEmpty()) {
            return "EMPTY";
          }
          StringBuilder builder = new StringBuilder();
          if (lowerBoundOpen) {
            builder.append("(");
          } else {
            builder.append("[");
          }
          if (lowerBound == null) {
            builder.append("-INF");
          } else {
            builder.append(lowerBound);
          }
          builder.append(", ");
          if (upperBound == null) {
            builder.append("INF");
          } else {
            builder.append(upperBound);
          }
          if (upperBoundOpen) {
            builder.append(")");
          } else {
            builder.append("]");
          }
          return builder.toString();
        }
      }
    learner_created: false
  - name: test/BiMapTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.io.ByteArrayOutputStream;
      import java.io.PrintStream;
      import java.lang.reflect.Constructor;
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      import java.lang.reflect.Modifier;
      import java.util.*;
      import java.util.regex.Pattern;
      
      class BiMapDelegateSearcher extends DelegateSearcher {
        void Initialize() {
          this.name = "BiMap";
        }
      
        void Validate() {
          if (original.getTypeParameters().length == 0) {
            throw new WrongAnswer(name + " Class must be a Generic Class.");
          }
      
          try {
            Constructor<?> publicConstr = original.getDeclaredConstructor();
            if (!Modifier.isPublic(publicConstr.getModifiers())) {
              throw new WrongAnswer(name + "'s constructor with no args should be public");
            }
          } catch (NoSuchMethodException e) {
            throw new WrongAnswer(name + "'s public constructor with no args is not found");
          }
      
          //Name, isStatic, returnType, argsType
          CustomMethod[] methods = new CustomMethod[]{
                  new CustomMethod("forcePut", false, Object.class, new Class[]{Object.class, Object.class}),
                  new CustomMethod("inverse", false, original, new Class[]{}),
                  new CustomMethod("put", false, Object.class, new Class[]{Object.class, Object.class}),
                  new CustomMethod("putAll", false, void.class, new Class[]{Map.class}),
                  new CustomMethod("values", false, Set.class, new Class[]{})
          };
      
          for (CustomMethod m : methods) {
            Method method;
            try {
              method = original.getMethod(m.getName(), m.getArgs());
            } catch (NoSuchMethodException e) {
              ArrayList<String> names = new ArrayList<>();
              for (Class<?> p : m.getArgs()) {
                if (p.equals(Object.class)) {
                  names.add("K");
                  names.add("V");
                  break;
                } else {
                  names.add(p.getSimpleName());
                }
              }
              if (names.isEmpty()) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method without args is not found");
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method with args " + names + " is not found");
              }
            }
      
            if (!method.getReturnType().equals(m.getReturnType())) {
              if (m.getReturnType().equals(Object.class)) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method must return V");
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method must return " + m.getReturnType().getSimpleName());
              }
            }
      
            if (!Modifier.isPublic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be public");
            }
          }
        }
      
        @Override
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | UnexpectedError |
                   StackOverflowError e) {
            if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("IllegalArgumentException")) {
              throw new IllegalArgumentException();
            }
            throw new WrongAnswer("Could not invoke " + name + "'s " + methodName + "() method correctly");
          }
        }
      }
      
      class BiMapBridge extends BiMapDelegateSearcher {
        public BiMapBridge() {
          try {
            instance = original.newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
            throw new WrongAnswer("Could not create new " + name + "'s instance");
          }
        }
      
        public Object put(Object key, Object value) {
          return invoke("put", new Class[]{Object.class, Object.class}, key, value);
        }
      
        public void putAll(Map<Object, Object> m) {
          invoke("putAll", new Class[]{Map.class}, m);
        }
      
        public Set<?> values() {
          return (Set<?>) invoke("values", new Class[]{});
        }
      
        public Object forcePut(Object key, Object value) {
          return invoke("forcePut", new Class[]{Object.class, Object.class}, key, value);
        }
      
        public Object inverse() {
          return invoke("inverse", new Class[]{});
        }
      
        public String toString() {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          PrintStream ps = new PrintStream(baos);
          PrintStream old = System.out;
          System.setOut(ps);
      
          try {
            System.out.print(instance);
          } catch (Throwable e) {
            throw new WrongAnswer("Unexpected " + e.getClass().getSimpleName() + " while parsing output from " +
                    "BiMap's toString()");
          }
      
          System.out.flush();
          System.setOut(old);
          return baos.toString();
        }
      }
      
      public class BiMapTests extends StageTest {
        Pattern pattern = Pattern.compile("\\{(\\w+=\\w+)+(?:, (\\w+=\\w+)+)*\\}|\\{\\}");
      
        Map<Object, Object> collToMap(Object s, Class<?> k, Class<?> v) {
          String[] elements = s.toString().replaceAll("\\s|\\{|\\}", "").split(",");
          Map<Object, Object> map = new HashMap<>();
          if (elements[0].equals("")) {
            return map;
          }
          for (String e : elements) {
            String[] kv = e.split("=");
            Object kObj = null, vObj = null;
            switch (k.getSimpleName()) {
              case "Character" -> kObj = kv[0].charAt(0);
              case "Integer" -> kObj = Integer.parseInt(kv[0]);
              case "String" -> kObj = kv[0];
            }
            switch (v.getSimpleName()) {
              case "Character" -> vObj = kv[1].charAt(0);
              case "Integer" -> vObj = Integer.parseInt(kv[1]);
              case "String" -> vObj = kv[1];
            }
            map.put(kObj, vObj);
          }
          return map;
        }
      
        void Check(BiMapBridge collection, Map<Object, Object> map,
                   Map<Object, Object> inverse, String methodName, Class<?> k, Class<?> v) {
          if (!pattern.matcher(collection.toString()).matches()) {
            throw new WrongAnswer("Instance of BiMap object should be printed as a map, just like in the example.");
          }
          try {
            if (!pattern.matcher(collection.inverse().toString()).matches()) {
              throw new WrongAnswer("Inverted instance of BiMap object should be printed as a map, just like in the example" +
                      ".");
            }
          } catch (IllegalArgumentException e) {
            throw new WrongAnswer("Unexpected " + e.getClass().getSimpleName() + " caught while inverting instance" +
                    "of an object with BiMap's inverse() method");
          }
      
          if (!methodName.equals("")) {
            if (!collToMap(collection, k, v).equals(map)) {
              System.out.println(collToMap(collection, k, v));
              System.out.println(map);
              throw new WrongAnswer("BiMap's " + methodName + "() method not working correctly");
            }
          }
      
          if (!collToMap(collection.inverse(), v, k).equals(inverse)) {
            System.out.println(collToMap(collection.inverse(), v, k));
            System.out.println(inverse);
            throw new WrongAnswer("BiMap's inverse() method not working correctly");
          }
      
          if (!collection.values().equals(inverse.keySet())) {
            throw new WrongAnswer("Incorrect result from BiMap's values() method.");
          }
        }
      
        @DynamicTest(order = 1)
        CheckResult test_empty() {
          BiMapBridge collection = new BiMapBridge();
      
          Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
      
          //Check_empty
          Check(collection, map, inverse, "", Object.class, Object.class);
          return CheckResult.correct();
        }
      
        Object[][] test_data = {
                {new Object[][]{{'a', 3}, {'b', 4}, {'c', 5}, {'d', 6}},
                        Character.class, Integer.class},
                {new Object[][]{{'a', "ABC"}, {'b', "BCD"}, {'c', "CDE"}, {'d', "DEF"}}, Character.class, String.class},
                {new Object[][]{{1, 3}, {2, 4}, {3, 5}, {4, 6}}, Integer.class, Integer.class}
        };
      
        @DynamicTest(data = "test_data", order = 2)
        CheckResult test_put(Object[][] data, Class<?> k, Class<?> v) {
          BiMapBridge collection = new BiMapBridge();
      
          Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
          //Check_put
          for (Object[] d : data) {
            collection.put(d[0], d[1]);
            map.put(d[0], d[1]);
            inverse.put(d[1], d[0]);
      
            Check(collection, map, inverse, "put", k, v);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 3)
        CheckResult test_put_illegal_key() {
          BiMapBridge collection = new BiMapBridge();
      
          collection.put('a', 3);
          collection.put('b', 4);
      
          boolean c = false;
          try {
            collection.put('a', 5);
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("BiMap's put() method should throw an IllegalArgumentException if " +
                    "a key or a value already exists in the BiMap");
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 4)
        CheckResult test_put_illegal_value() {
          BiMapBridge collection = new BiMapBridge();
      
          collection.put('a', 3);
          collection.put('b', 4);
      
          boolean c = false;
          try {
            collection.put('c', 4);
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("BiMap's put() method should throw an IllegalArgumentException if " +
                    "a key or a value already exists in the BiMap");
          }
      
          return CheckResult.correct();
        }
      
        Object[][] test_maps = {
                {
                        new Map[]{
                                Map.of('a', 3, 'b', 4, 'c', 5, 'd', 6),
                                Map.of('e', 7, 'f', 8, 'g', 9, 'h', 10)
                        },
                        Character.class, Integer.class
                },
                {
                        new Map[]{
                                Map.of('a', "ABC", 'b', "BCD", 'c', "CDE", 'd', "DEF"),
                                Map.of('e', "EFG", 'f', "FGH", 'g', "GHK", 'h', "HKL")
                        },
                        Character.class, String.class
                },
                {
                        new Map[]{
                                Map.of(1, 3, 2, 4, 3, 5, 4, 6),
                                Map.of(5, 7, 6, 8, 7, 9, 8, 10)
                        },
                        Integer.class, Integer.class
                },
        };
      
        @DynamicTest(data = "test_maps", order = 5)
        CheckResult test_putAll(Map<Object, Object>[] maps, Class<?> k, Class<?> v) {
          BiMapBridge collection = new BiMapBridge();
      
          Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
      
          //Check_putAll
          for (Map<Object, Object> m : maps) {
            for (Map.Entry<Object, Object> e : m.entrySet()) {
              map.put(e.getKey(), e.getValue());
              inverse.put(e.getValue(), e.getKey());
            }
      
            collection.putAll(m);
      
            Check(collection, map, inverse, "putAll", k, v);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 6)
        CheckResult test_putAll_illegal_values() {
          BiMapBridge collection = new BiMapBridge();
      
          collection.putAll(Map.of('a', 3, 'b', 4, 'c', 5, 'd', 6));
      
          boolean c = false;
          try {
            collection.putAll(Map.of('e', 5, 'f', 6));
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("BiMap's putAll() method should throw an IllegalArgumentException if " +
                    "a key or a value already exists in the BiMap");
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 7)
        CheckResult test_putAll_illegal_keys() {
          BiMapBridge collection = new BiMapBridge();
      
          collection.putAll(Map.of('a', 3, 'b', 4, 'c', 5, 'd', 6));
      
          boolean c = false;
          try {
            collection.putAll(Map.of('a', 7, 'b', 8));
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("BiMap's putAll() method should throw an IllegalArgumentException if " +
                    "a key or a value already exists in the BiMap");
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(data = "test_data", order = 8)
        CheckResult test_forcePut_as_put(Object[][] data, Class<?> k, Class<?> v) {
          BiMapBridge collection = new BiMapBridge();
      
          Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
      
          //Check_forcePut
          for (Object[] d : data) {
            if (map.containsKey(d[0])) {
              Object value = map.get(d[0]);
              map.remove(d[0]);
              inverse.remove(value);
            }
            map.put(d[0], d[1]);
            inverse.put(d[1], d[0]);
      
            collection.forcePut(d[0], d[1]);
      
            Check(collection, map, inverse, "forcePut", k, v);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 9)
        CheckResult test_forcePut() {
      
          Object[][] data = new Object[][]{{'a', 3}, {'b', 4}, {'c', 5}, {'d', 6}, {'e', 7},
                  {'f', 6}, {'g', 7}, {'h', 6},
                  {'a', 8}, {'b', 9}, {'a', 10},
                  {'c', 5}};
      
          BiMapBridge collection = new BiMapBridge();
      
          Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
      
          //Check_forcePut
          for (Object[] d : data) {
            Object value, key;
      
            value = map.get(d[0]);
            if (value != null) {
              map.remove(d[0]);
              inverse.remove(value);
            }
            key = inverse.get(d[1]);
            if (key != null) {
              map.remove(key);
              inverse.remove(d[1]);
            }
      
            map.put(d[0], d[1]);
            inverse.put(d[1], d[0]);
      
            try {
              collection.forcePut(d[0], d[1]);
            } catch (IllegalArgumentException e) {
              CheckResult.wrong("BiMap's forcePut() method not working correctly " + e.getMessage());
            }
      
            Check(collection, map, inverse, "forcePut", Character.class, Integer.class);
          }
      
          return CheckResult.correct();
        }
      
      //
      //  Object[][] test_combined = {
      //          {
      //                  new Object[][]{{'a', 3}, {'b', 4}, {'c', 5}, {'d', 6}, {'a', 7}, {'b', 3}, {'e', 5}, {'f', 6}},
      //                  new Map[]{
      //                          Map.of('a', 3, 'b', 4, 'c', 5, 'd', 6),
      //                          Map.of('a', 7, 'e', 4, 'f', 8, 'd', 7),
      //                          Map.of('a', 7, 'c', 2, 'f', 5, 'g', 3)
      //                  },
      //                  Character.class, Integer.class
      //          },
      //          {
      //                  new Object[][]{{'a', "ABC"}, {'b', "BCD"}, {'c', "CDE"}, {'d', "DEF"}, {'a', "EFG"}, {'b', "ABD"},
      //                          {'e',
      //                                  "CDE"}, {'f', "DEF"}},
      //                  new Map[]{
      //                          Map.of('a', "ABC", 'b', "BCD", 'c', "CDE", 'd', "DEF"),
      //                          Map.of('a', "EFG", 'e', "BCD", 'f', "FGH", 'd', "EFG"),
      //                          Map.of('a', "EFG", 'c', "ABB", 'f', "CDE", 'g', "ABC")
      //                  },
      //                  Character.class, String.class
      //          },
      //          {
      //                  new Object[][]{{1, 3}, {2, 4}, {3, 5}, {4, 6}, {1, 7}, {2, 3}, {5, 5}, {6, 6}},
      //                  new Map[]{
      //                          Map.of(1, 3, 2, 4, 3, 5, 4, 6),
      //                          Map.of(1, 7, 5, 4, 6, 8, 4, 7),
      //                          Map.of(1, 7, 3, 2, 6, 5, 7, 3)
      //                  },
      //                  Integer.class, Integer.class
      //          },
      //  };
      //
      //  @DynamicTest(data = "test_combined", order = 5, repeat = 5)
      //  CheckResult test_everything(Object[][] data, Map<Object, Object>[] maps, Class<?> k, Class<?> v) {
      //    BiMapBridge collection = new BiMapBridge();
      //
      //    Map<Object, Object> map = new HashMap<>(), inverse = new HashMap<>();
      //
      //    int putCase = 0; // 8
      //    int mapCase = 0; // 3
      //
      //    Random rd = new Random();
      //
      //    //Check
      //    while (putCase != 8 || mapCase != 3) {
      //      boolean ch = rd.nextBoolean();
      //      String methodName = "";
      //      if (ch && putCase != 8 || mapCase == 3) {
      //        ch = rd.nextBoolean();
      //        Object kObj = data[putCase][0], vObj = data[putCase][1];
      //
      //        if (ch) {
      //          methodName = "put";
      //
      //          map.put(kObj, vObj);
      //          inverse.put(vObj, kObj);
      //          collection.put(kObj, vObj);
      //        } else {
      //          methodName = "forcePut";
      //
      //          if (map.containsKey(kObj)) {
      //            Object value = map.get(kObj);
      //            map.remove(kObj);
      //            inverse.remove(value);
      //          }
      //          map.put(kObj, vObj);
      //          inverse.put(vObj, kObj);
      //          collection.forcePut(kObj, vObj);
      //        }
      //        putCase++;
      //      } else {
      //        methodName = "putAll";
      //
      //        for (Map.Entry<Object, Object> e : maps[mapCase].entrySet()) {
      //          map.put(e.getKey(), e.getValue());
      //          inverse.put(e.getValue(), e.getKey());
      //        }
      //
      //        collection.putAll(maps[mapCase]);
      //        mapCase++;
      //      }
      //      Check(collection, map, inverse, methodName, k, v);
      //    }
      //    return CheckResult.correct();
      //  }
      }
    learner_created: false
  - name: test/Helper.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      
      class CustomMethod {
        private final String name;
        private final boolean isStatic;
        private final Class<?> returnType;
        private final Class<?>[] args;
      
        public CustomMethod(String name, boolean isStatic, Class<?> returnType, Class<?>[] args) {
          this.name = name;
          this.isStatic = isStatic;
          this.returnType = returnType;
          this.args = args;
        }
      
        public String getName() {
          return name;
        }
      
        public Class<?> getReturnType() {
          return returnType;
        }
      
        public Class<?>[] getArgs() {
          return args;
        }
      
        public boolean isStatic() {
          return isStatic;
        }
      }
      
      abstract class DelegateSearcher {
        Class<?> original;
        Object instance;
        String name;
      
        public DelegateSearcher() {
          Initialize();
          for (Class<?> c : ReflectionUtils.getAllClassesFromPackage("collections")) {
            if (c.getSimpleName().equals(name)) {
              original = c;
              Validate();
              return;
            }
          }
          throw new WrongAnswer("Could not Find "+name+" Class");
        }
      
        abstract void Initialize();
        abstract void Validate();
      
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
            throw new WrongAnswer("Could not invoke " +name+"'s "+ methodName + "() method correctly.");
          }
        }
      }
    learner_created: false
  - name: test/ImmutabilityTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      import java.lang.reflect.Modifier;
      import java.util.ArrayList;
      import java.util.Arrays;
      
      class ImmutableDelegateSearcher extends DelegateSearcher {
        void Initialize() {
          this.name = "ImmutableCollection";
        }
      
        void Validate() {
          if (!Modifier.isFinal(original.getModifiers())) {
            throw new WrongAnswer(name + " Class must be a final Class");
          }
          if (original.getTypeParameters().length == 0) {
            throw new WrongAnswer(name + " Class must be a Generic Class.");
          }
          for (var c : original.getDeclaredConstructors()) {
            if (Modifier.isPublic(c.getModifiers())) {
              throw new WrongAnswer("None of the " + name + "'s constructors should be public");
            }
          }
          //Name, isStatic, returnType, argsType
          CustomMethod[] methods = new CustomMethod[]{
                  new CustomMethod("of", true, original, new Class[]{}),
                  new CustomMethod("of", true, original, new Class[]{Object[].class}),
                  new CustomMethod("contains", false, boolean.class, new Class[]{Object.class}),
                  new CustomMethod("size", false, int.class, new Class[]{}),
                  new CustomMethod("isEmpty", false, boolean.class, new Class[]{})
          };
      
          for (CustomMethod m : methods) {
            Method method;
            try {
              method = original.getMethod(m.getName(), m.getArgs());
            } catch (NoSuchMethodException e) {
      
              ArrayList<String> names = new ArrayList<>();
              for (Class<?> p : m.getArgs()) {
                if (p.equals(Object.class)) {
                  names.add("E");
                } else if (p.equals(Object[].class)) {
                  names.add("E[]");
                } else {
                  names.add(p.getSimpleName());
                }
              }
              if (names.isEmpty()) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method without args is not found");
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method with args " + names + " is not found");
              }
            }
      
            if (m.isStatic() && !Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be static");
            }
            if (!m.isStatic() && Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must not be static");
            }
      
            if (!method.getReturnType().equals(m.getReturnType())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must return " + m.getReturnType().getSimpleName());
            }
      
            if (!Modifier.isPublic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be public");
            }
          }
        }
      
        @Override
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | UnexpectedError | StackOverflowError e) {
            if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("NullPointerException")) {
              throw new NullPointerException();
            }
      
            throw new WrongAnswer("Could not invoke " + name + "'s " + methodName + "() method correctly or it is throwing " +
                    "wrong exception for a null element or invalid range");
          }
        }
      }
      
      class ImmutableBridge extends ImmutableDelegateSearcher {
      
        public void of() {
          instance = invoke("of", new Class[]{});
        }
      
        public void of(Object... objs) {
          instance = invoke("of", new Class[]{Object[].class}, new Object[]{objs});
        }
      
        public int size() {
          return (int) invoke("size", new Class[]{});
        }
      
        public boolean contains(Object element) {
          return (boolean) invoke("contains", new Class[]{Object.class}, element);
        }
      
        public boolean isEmpty() {
          return (boolean) invoke("isEmpty", new Class[]{});
        }
      }
      
      public class ImmutabilityTests extends StageTest {
      
        @DynamicTest()
        CheckResult testNPE() {
          ImmutableBridge collection = new ImmutableBridge();
          boolean c = false;
          try {
            collection.of(new Object[]{null});
          } catch (NullPointerException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("ImmutableCollection's of() method should throw a NullPointerException if " +
                    "any of provided arguments is equal to 'null'");
          }
      
          c = false;
          try {
            collection.contains(null);
          } catch (NullPointerException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("ImmutableCollection's contains() method should throw a NullPointerException if " +
                    "any of provided arguments is equal to 'null'");
          }
      
          return CheckResult.correct();
        }
      
        //{<Array>, <!contains>}
        Object[][] test_data = {
                {new Object[]{}, new Object[]{"ABC", 1, 'a'}},
                {new Integer[]{1, 2, 3, 4}, new Object[]{"ABC", 5, 'a'}},
                {new Character[]{'a', 'b', 'c'}, new Object[]{"ABC", 1, 'd'}},
                {new String[]{"ABC", "XYZ", "MNO", "PQR"}, new Object[]{"Hello", 1, 'a'}},
        };
      
        @DynamicTest(data = "test_data", order = 1)
        CheckResult test(Object[] array, Object[] nContains) {
      
          ImmutableBridge collection = new ImmutableBridge();
          String method = "of()";
          try {
            if (array.length == 0) {
              collection.of();
            } else {
              collection.of(array);
            }
            method = "size()";
            if (collection.size() != array.length) {
              return CheckResult.wrong("Incorrect result from ImmutableCollection's size() method.");
            }
            method = "isEmpty()";
            if (collection.isEmpty() != (array.length == 0)) {
              return CheckResult.wrong("Incorrect result from ImmutableCollection's isEmpty() method.");
            }
            method = "contains()";
            for (Object i : array) {
              if (!collection.contains(i)) {
                return CheckResult.wrong("Incorrect result from ImmutableCollection's contains() method.");
              }
            }
            for (Object i : nContains) {
              if (collection.contains(i)) {
                return CheckResult.wrong("Incorrect result from ImmutableCollection's contains() method.");
              }
            }
          } catch (NullPointerException e) {
            return CheckResult.wrong("Incorrect result from ImmutableCollection's " + method + " method. " +
                    "Caught: NullPointerException");
          }
      
          return CheckResult.correct();
        }
      }
    learner_created: false
  - name: test/MultisetTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.io.ByteArrayOutputStream;
      import java.io.PrintStream;
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      import java.lang.reflect.Modifier;
      import java.util.*;
      import java.util.regex.Pattern;
      
      class MultisetDelegateSearcher extends DelegateSearcher {
        void Initialize() {
          this.name = "Multiset";
        }
      
        void Validate() {
          if (original.getTypeParameters().length == 0) {
            throw new WrongAnswer(name + " Class must be a Generic Class.");
          }
          //Name, isStatic, returnType, argsType
          CustomMethod[] methods = new CustomMethod[]{
                  new CustomMethod("add", false, void.class, new Class[]{Object.class, int.class}),
                  new CustomMethod("add", false, void.class, new Class[]{Object.class}),
                  new CustomMethod("contains", false, boolean.class, new Class[]{Object.class}),
                  new CustomMethod("count", false, int.class, new Class[]{Object.class}),
                  new CustomMethod("elementSet", false, Set.class, new Class[]{}),
                  new CustomMethod("remove", false, void.class, new Class[]{Object.class}),
                  new CustomMethod("remove", false, void.class, new Class[]{Object.class, int.class}),
                  new CustomMethod("setCount", false, void.class, new Class[]{Object.class, int.class}),
                  new CustomMethod("setCount", false, void.class, new Class[]{Object.class, int.class, int.class})
          };
      
          for (CustomMethod m : methods) {
            Method method;
            try {
              method = original.getMethod(m.getName(), m.getArgs());
            } catch (NoSuchMethodException e) {
              ArrayList<String> names = new ArrayList<>();
              for(Class<?> p : m.getArgs()){
                if(p.equals(Object.class)){
                  names.add("E");
                }else if(p.equals(Object[].class)){
                  names.add("E[]");
                }else{
                  names.add(p.getSimpleName());
                }
              }
              if(names.isEmpty()){
                throw new WrongAnswer(name+"'s "+m.getName() + "() method without args is not found");
              }else{
                throw new WrongAnswer(name+"'s "+m.getName() + "() method with args " + names + " is not found");
              }
            }
      
            if (!method.getReturnType().equals(m.getReturnType())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must return " + m.getReturnType().getSimpleName());
            }
      
            if (!Modifier.isPublic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be public");
            }
          }
        }
        @Override
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | UnexpectedError | StackOverflowError e) {
            throw new WrongAnswer("Could not invoke " + name + "'s " + methodName + "() method correctly: " + e.getMessage());
          }
        }
      }
      
      class MultisetBridge extends MultisetDelegateSearcher {
      
        public MultisetBridge() {
          try {
            instance = original.newInstance();
          } catch (InstantiationException | IllegalAccessException e) {
            throw new WrongAnswer("Could not create new " + name + "'s instance");
          }
        }
      
        public void add(Object element, int occurrences) {
          invoke("add", new Class[]{Object.class, int.class}, element, occurrences);
        }
      
        public void add(Object element) {
          invoke("add", new Class[]{Object.class}, element);
        }
      
        public boolean contains(Object element) {
          return (boolean) invoke("contains", new Class[]{Object.class}, element);
        }
      
        public int count(Object element) {
          return (int) invoke("count", new Class[]{Object.class}, element);
        }
      
        public Set<?> elementSet() {
          return (Set<?>) invoke("elementSet", new Class[]{});
        }
      
        public void remove(Object element) {
          invoke("remove", new Class[]{Object.class}, element);
        }
      
        public void remove(Object element, int occurences) {
          invoke("remove", new Class[]{Object.class, int.class}, element, occurences);
        }
      
        public void setCount(Object element, int count) {
          invoke("setCount", new Class[]{Object.class, int.class}, element, count);
        }
      
        public void setCount(Object element, int oldCount, int newCount) {
          invoke("setCount", new Class[]{Object.class, int.class, int.class}, element, oldCount, newCount);
        }
      
        public String toString() {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          PrintStream ps = new PrintStream(baos);
          PrintStream old = System.out;
          System.setOut(ps);
      
          try {
            System.out.print(instance);
          } catch (Throwable e) {
            throw new WrongAnswer("Unexpected " + e.getClass().getSimpleName() + " while parsing output from " +
                    "Multiset's toString()");
          }
      
          System.out.flush();
          System.setOut(old);
          return baos.toString();
        }
      }
      
      public class MultisetTests extends StageTest {
        Pattern pattern = Pattern.compile("\\[\\w+(?:, \\w+)*\\]|\\[\\]");
      
        String mapToString(Map<Object, Integer> map) {
          List<Object> list = new ArrayList<>();
          for (var it : map.entrySet()) {
            for (int i = 0; i < it.getValue(); i++) {
              list.add(it.getKey());
            }
          }
          return list.toString();
        }
      
        void Check(MultisetBridge collection, Map<Object, Integer> map, String methodName) {
          if (!pattern.matcher(collection.toString()).matches()) {
            throw new WrongAnswer("Instance of Multiset object should be printed as a list, just like in the example.");
          }
          if (!methodName.equals(""))
            if (!collection.toString().equals(mapToString(map))) {
              throw new WrongAnswer("Multiset's " + methodName + "() method not working correctly");
            }
          if (!map.keySet().equals(collection.elementSet())) {
            throw new WrongAnswer("Incorrect result from Multiset's elementSet() method.");
          }
      
          for (Object i : new Object[]{1, 'a', "ABC"}) {
            if (collection.contains(i)) {
              throw new WrongAnswer("Incorrect result from Multiset's contains() method.");
            }
          }
          for (Object i : map.keySet()) {
            if (map.containsKey(i) != collection.contains(i)) {
              throw new WrongAnswer("Incorrect result from Multiset's contains() method.");
            }
          }
      
          for (Object i : new Object[]{1, 'a', "ABC"}) {
            if (collection.count(i) != 0) {
              throw new WrongAnswer("Incorrect result from Multiset's count() method.");
            }
          }
          for (Object i : map.keySet()) {
            if (Optional.ofNullable(map.get(i)).orElse(0) != collection.count(i)) {
              throw new WrongAnswer("Incorrect result from Multiset's count() method.");
            }
          }
        }
      
        @DynamicTest(order = 1)
        CheckResult testEmpty() {
          MultisetBridge collection = new MultisetBridge();
          Map<Object, Integer> map = new HashMap<>();
          Check(collection, map, "");
          return CheckResult.correct();
        }
      
        Object[][] test_data = {
                {new Integer[]{2, 3, 4}},
                {new Character[]{'b', 'c', 'd'}},
                {new String[]{"DEF", "XYZ", "MNO"}},
                {new Object[]{2, 'b', "DEF"}}
        };
      
        @DynamicTest(data = "test_data", order = 2)
        CheckResult testAdd(Object[] array) {
          Map<Object, Integer> map = new HashMap<>();
          MultisetBridge collection = new MultisetBridge();
          for (Object i : array) {
            //Add zero elements
            collection.add(i, 0);
            Check(collection, map, "add");
      
            //Add one element
            map.put(i, 1);
            collection.add(i);
            Check(collection, map, "add");
      
            //Add zero elements again
            collection.add(i, 0);
            Check(collection, map, "add");
      
            //Add 3 more elements
            map.put(i, 4);
            collection.add(i, 3);
            Check(collection, map, "add");
      
            //Add -1 element
            collection.add(i,-1);
            Check(collection, map, "add");
      
            //Add 5 more elements
            map.put(i, 9);
            collection.add(i, 5);
            Check(collection, map, "add");
          }
      
          return CheckResult.correct();
        }
      
      
        @DynamicTest(data = "test_data", order = 3)
        CheckResult testRemove(Object[] array) {
          Map<Object, Integer> map = new HashMap<>();
          MultisetBridge collection = new MultisetBridge();
      
          for (Object i : array) {
            //Remove with 0 occurrences
            collection.remove(i);
            Check(collection, map, "remove");
            collection.remove(i, 5);
            Check(collection, map, "remove");
      
            //Add 5
            map.put(i, 5);
            collection.add(i, 5);
      
            //Remove 0
            collection.remove(i,0);
            Check(collection, map, "remove");
      
            //Remove 1
            map.put(i, 4);
            collection.remove(i);
            Check(collection, map, "remove");
      
            //Remove 2
            map.put(i, 2);
            collection.remove(i, 2);
            Check(collection, map, "remove");
      
            //Remove -1
            collection.remove(i, -1);
            Check(collection, map, "remove");
      
            //Remove last
            map.remove(i);
            collection.remove(i, 2);
            Check(collection, map, "remove");
      
            //Add 2 more
            map.put(i, 2);
            collection.add(i, 2);
      
            //Remove more than last
            map.remove(i);
            collection.remove(i, 5);
            Check(collection, map, "remove");
      
            //Add 5 more
            map.put(i, 5);
            collection.add(i, 5);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(data = "test_data", order = 4)
        CheckResult testSetCount(Object[] array) {
          Map<Object, Integer> map = new HashMap<>();
          MultisetBridge collection = new MultisetBridge();
      
          for (Object i : array) {
            //Set count with 0
            collection.setCount(i,5);
            Check(collection, map, "setCount");
            collection.setCount(i, 2,5);
            Check(collection, map, "setCount");
      
            //Add 3
            map.put(i, 3);
            collection.add(i, 3);
      
            //setCount, wrong oldCount
            collection.setCount(i,2, 5);
            Check(collection, map, "setCount");
      
            //setCount, -1
            collection.setCount(i,-1);
            Check(collection, map, "setCount");
      
            //setCount, -1 newCount
            collection.setCount(i,3,-1);
            Check(collection, map, "setCount");
      
            //setCount, from 3 to 5
            map.put(i,5);
            collection.setCount(i,3,5);
            Check(collection, map, "setCount");
      
            //setCount, to 1
            map.put(i,1);
            collection.setCount(i,1);
            Check(collection, map, "setCount");
      
            //setCount, to 0
            map.remove(i);
            collection.setCount(i,0);
            Check(collection, map, "setCount");
      
            //Add 3 more
            map.put(i, 3);
            collection.add(i, 3);
      
            //setCount, to 3 as well
            collection.setCount(i,3,3);
            Check(collection, map, "setCount");
      
            collection.setCount(i,3);
            Check(collection, map, "setCount");
      
            //setCount, to 0 newCount
            map.remove(i);
            collection.setCount(i,3,0);
            Check(collection, map, "setCount");
      
            //Add 3 more
            map.put(i, 3);
            collection.add(i, 3);
          }
          return CheckResult.correct();
        }
      }
    learner_created: false
  - name: test/QueueTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.io.ByteArrayOutputStream;
      import java.io.PrintStream;
      import java.lang.reflect.Constructor;
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      import java.lang.reflect.Modifier;
      import java.util.*;
      import java.util.regex.Pattern;
      
      class SizeLimitedQueueDelegateSearcher extends DelegateSearcher {
        void Initialize() {
          this.name = "SizeLimitedQueue";
        }
      
        void Validate() {
          if (original.getTypeParameters().length == 0) {
            throw new WrongAnswer(name + " Class must be a Generic Class.");
          }
          try {
            Constructor<?> constr = original.getDeclaredConstructor(int.class);
            if (!Modifier.isPublic(constr.getModifiers())) {
              throw new WrongAnswer(name + "'s constructor with args [" + int.class.getSimpleName() + "] should be public");
            }
          } catch (NoSuchMethodException e) {
            throw new WrongAnswer(name + "'s public constructor with args [" + int.class.getSimpleName() + "] is not found");
          }
          //Name, isStatic, returnType, argsType
          CustomMethod[] methods = new CustomMethod[]{
                  new CustomMethod("add", false, void.class, new Class[]{Object.class}),
                  new CustomMethod("clear", false, void.class, new Class[]{}),
                  new CustomMethod("isAtFullCapacity", false, boolean.class, new Class[]{}),
                  new CustomMethod("isEmpty", false, boolean.class, new Class[]{}),
                  new CustomMethod("maxSize", false, int.class, new Class[]{}),
                  new CustomMethod("peek", false, Object.class, new Class[]{}),
                  new CustomMethod("remove", false, Object.class, new Class[]{}),
                  new CustomMethod("size", false, int.class, new Class[]{}),
                  new CustomMethod("toArray", false, Object[].class, new Class[]{Object[].class}),
                  new CustomMethod("toArray", false, Object[].class, new Class[]{}),
          };
      
          for (CustomMethod m : methods) {
            Method method;
            try {
              method = original.getMethod(m.getName(), m.getArgs());
            } catch (NoSuchMethodException e) {
      
              ArrayList<String> names = new ArrayList<>();
              for (Class<?> p : m.getArgs()) {
                if (p.equals(Object.class)) {
                  names.add("E");
                } else if (p.equals(Object[].class)) {
                  names.add("E[]");
                } else {
                  names.add(p.getSimpleName());
                }
              }
              if (names.isEmpty()) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method without args is not found");
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method with args " + names + " is not found");
              }
            }
      
            if (m.isStatic() && !Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be static");
            }
            if (!m.isStatic() && Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must not be static");
            }
            if (!method.getReturnType().equals(m.getReturnType())) {
              if (m.getReturnType().equals(Object.class)) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method must return E");
              } else if (m.getReturnType().equals(Object[].class)) {
                if (m.getArgs().length != 0) {
                  throw new WrongAnswer(name + "'s " + m.getName() + "() method with args E[] must return E[]");
                } else {
                  throw new WrongAnswer(name + "'s " + m.getName() + "() method without args must return Object[]");
                }
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method must return " + m.getReturnType().getSimpleName());
              }
            }
      
            if (!Modifier.isPublic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be public");
            }
          }
        }
      
        @Override
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | UnexpectedError | StackOverflowError e) {
            String add = ".";
      
            if (methodName.equals("remove")) {
              if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("NoSuchElementException")) {
                throw new NoSuchElementException();
              } else {
                add = " or it is throwing wrong exception for empty queue";
              }
            }
      
            if (methodName.equals("add")) {
              if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("NullPointerException")) {
                throw new NullPointerException();
              } else {
                add = " or it is throwing wrong exception for a null object argument";
              }
            }
      
            throw new WrongAnswer("Could not invoke " + name + "'s " + methodName + "() method correctly" + add);
          }
        }
      }
      
      class SizeLimitedQueueBridge extends SizeLimitedQueueDelegateSearcher {
      
        public SizeLimitedQueueBridge(int limit) {
          try {
            Constructor<?> constr = original.getDeclaredConstructor(int.class);
            instance = constr.newInstance(limit);
          } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
            if (e.getCause().getClass().getSimpleName().equals("IllegalArgumentException")) {
              throw new IllegalArgumentException();
            }
            throw new WrongAnswer("Could not create new " + name + "'s instance or constructor is throwing wrong exception " +
                    "for non-positive limit");
          }
        }
      
        public void add(Object element) {
          invoke("add", new Class[]{Object.class}, element);
        }
      
        public void clear() {
          invoke("clear", new Class[]{});
        }
      
        public boolean isAtFullCapacity() {
          return (boolean) invoke("isAtFullCapacity", new Class[]{});
        }
      
        public boolean isEmpty() {
          return (boolean) invoke("isEmpty", new Class[]{});
        }
      
        public int maxSize() {
          return (int) invoke("maxSize", new Class[]{});
        }
      
        public Object peek() {
          return invoke("peek", new Class[]{});
        }
      
        public Object remove() {
          return invoke("remove", new Class[]{});
        }
      
        public int size() {
          return (int) invoke("size", new Class[]{});
        }
      
        public Object[] toArray(Object[] objs) {
          return (Object[]) invoke("toArray", new Class[]{Object[].class}, new Object[]{objs});
        }
      
        public Object[] toArray() {
          return (Object[]) invoke("toArray", new Class[]{});
        }
      
        public String toString() {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          PrintStream ps = new PrintStream(baos);
          PrintStream old = System.out;
          System.setOut(ps);
      
          try {
            System.out.print(instance);
          } catch (Throwable e) {
            throw new WrongAnswer("Unexpected " + e.getClass().getSimpleName() + " while parsing output from " +
                    "SizeLimitedQueue's toString()");
          }
      
          System.out.flush();
          System.setOut(old);
          return baos.toString();
        }
      }
      
      public class QueueTests extends StageTest {
        Pattern pattern = Pattern.compile("\\[\\w+(?:, \\w+)*\\]|\\[\\]");
      
        void Check(SizeLimitedQueueBridge collection, Queue<Object> q, int limit, String methodName, Object[] ref,
                   Class<?> cl) {
          if (!pattern.matcher(collection.toString()).matches()) {
            throw new WrongAnswer("Instance of SizeLimitedQueue object should be printed as a list, just like in the " +
                    "example.");
          }
          if (!methodName.equals(""))
            if (!collection.toString().equals(Arrays.toString(q.toArray()))) {
              throw new WrongAnswer("SizeLimitedQueue's " + methodName + "() method not working correctly");
            }
      
          //Side methods check
          if ((q.size() == limit) != collection.isAtFullCapacity()) {
            throw new WrongAnswer("Incorrect result from SizeLimitedQueue's isAtFullCapacity() method.");
          }
          if ((q.isEmpty()) != collection.isEmpty()) {
            throw new WrongAnswer("Incorrect result from SizeLimitedQueue's isEmpty() method.");
          }
          if (collection.maxSize() != limit) {
            throw new WrongAnswer("Incorrect result from SizeLimitedQueue's maxSize() method.");
          }
          if (collection.peek() != q.peek()) {
            throw new WrongAnswer("Incorrect result from SizeLimitedQueue's peek() method.");
          }
          if (collection.size() != q.size()) {
            throw new WrongAnswer("Incorrect result from SizeLimitedQueue's size() method.");
          }
      
          //Arrays check
          if (!methodName.equals("")) {
            if (collection.toArray().length != q.toArray().length) {
              throw new WrongAnswer("Incorrect result from SizeLimitedQueue's toArray() method.");
            }
            if (collection.toArray(ref).length != q.toArray().length) {
              throw new WrongAnswer("Incorrect result from SizeLimitedQueue's toArray(E[]) method.");
            }
      
            if (!collection.toArray().getClass().getSimpleName().equals(Object[].class.getSimpleName())) {
              throw new WrongAnswer("Incorrect return type from SizeLimitedQueue's toArray() method.");
            }
            if (!collection.toArray(ref).getClass().getSimpleName().equals(cl.getSimpleName())) {
              throw new WrongAnswer("Incorrect return type from SizeLimitedQueue's toArray(E[]) method.");
            }
      
            for (int j = 0; j < q.toArray().length; j++) {
              if (collection.toArray()[j] != q.toArray()[j]) {
                throw new WrongAnswer("Incorrect result from SizeLimitedQueue's toArray() method.");
              }
              if (collection.toArray(ref)[j] != q.toArray()[j]) {
                throw new WrongAnswer("Incorrect result from SizeLimitedQueue's toArray(E[]) method.");
              }
            }
          }
        }
      
        @DynamicTest()
        CheckResult test_ex() {
          boolean c = false;
          //Non-positive limit
          try {
            new SizeLimitedQueueBridge(-1);
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("SizeLimitedQueue's constructor should throw an IllegalArgumentException if provided" +
                    " limit is negative");
          }
          c = false;
          try {
            new SizeLimitedQueueBridge(0);
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("SizeLimitedQueue's constructor should throw an IllegalArgumentException if provided" +
                    " limit is equal to zero");
          }
          //Positive limit
          SizeLimitedQueueBridge collection;
          try {
            collection = new SizeLimitedQueueBridge(1);
          } catch (IllegalArgumentException e) {
            return CheckResult.wrong("SizeLimitedQueue's constructor should not throw an IllegalArgumentException if " +
                    "provided limit is positive");
          }
          //Remove for empty
          c = false;
          try {
            collection.remove();
          } catch (NoSuchElementException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("SizeLimitedQueue's remove() method should throw an NoSuchElementException for an " +
                    "empty queue");
          }
          //Add null
          c = false;
          try {
            collection.add(null);
          } catch (NullPointerException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("SizeLimitedQueue's add() method should throw an NullPointerException for a null " +
                    "object argument");
          }
          //Peek for empty
          if (collection.peek() != null) {
            return CheckResult.wrong("SizeLimitedQueue's peek() method should return null for an empty queue");
          }
          //Add not null
          try {
            collection.add(1);
          } catch (NullPointerException e) {
            return CheckResult.wrong("SizeLimitedQueue's add() method should not throw an NullPointerException for a " +
                    "non-null object arguments");
          }
          //Remove for non empty
          try {
            collection.remove();
          } catch (NoSuchElementException e) {
            return CheckResult.wrong("SizeLimitedQueue's remove() method should not throw an NoSuchElementException for a " +
                    "non-empty queue");
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest()
        CheckResult test_empty() {
          int limit = 5;
          SizeLimitedQueueBridge collection = new SizeLimitedQueueBridge(limit);
          Deque<Object> q = new ArrayDeque<>();
          Check(collection, q, limit, "", new Object[0], Object.class);
          return CheckResult.correct();
        }
      
        Object[][] test_data = {
                {3, new Integer[]{2, 3, 4, 5, 6, 7, 8, 9, 10}, new Integer[0], Integer[].class},
                {3, new Character[]{'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}, new Character[0], Character[].class},
                {3, new String[]{"BCD", "CDE", "DEF", "EFG", "FGH", "GHI", "HIJ", "IJK", "JKL"}, new String[0],
                        String[].class},
                {5, new Integer[]{2, 3, 4, 5, 6, 7, 8, 9, 10}, new Integer[0], Integer[].class},
                {5, new Character[]{'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}, new Character[0], Character[].class},
                {5, new String[]{"BCD", "CDE", "DEF", "EFG", "FGH", "GHI", "HIJ", "IJK", "JKL"}, new String[0],
                        String[].class},
                {8, new Integer[]{2, 3, 4, 5, 6, 7, 8, 9, 10}, new Integer[0], Integer[].class},
                {8, new Character[]{'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}, new Character[0], Character[].class},
                {8, new String[]{"BCD", "CDE", "DEF", "EFG", "FGH", "GHI", "HIJ", "IJK", "JKL"}, new String[0],
                        String[].class}
        };
      
        @DynamicTest(data = "test_data")
        CheckResult test_actions(int limit, Object[] array, Object[] ref, Class<?> cl) {
          SizeLimitedQueueBridge collection = new SizeLimitedQueueBridge(limit);
          Deque<Object> q = new ArrayDeque<>();
          //Add
          for (Object i : array) {
            collection.add(i);
            if (q.size() == limit) {
              q.removeFirst();
            }
            q.add(i);
            Check(collection, q, limit, "add", ref, cl);
          }
      
          //Remove
          for (int i = 0; i < limit; i++) {
            Object a = q.remove();
            Object b = collection.remove();
            if(a!=b){
              return CheckResult.wrong("Incorrect result from SizeLimitedQueue's remove() method.");
            }
            Check(collection, q, limit, "remove", ref, cl);
          }
      
          //Remove after adding more
          q.add(array[0]);
          collection.add(array[0]);
          Check(collection, q, limit, "add", ref, cl);
          Object a = q.remove();
          Object b = collection.remove();
          if(a!=b){
            return CheckResult.wrong("Incorrect result from SizeLimitedQueue's remove() method.");
          }
          Check(collection, q, limit, "remove", ref, cl);
      
          //Add and clear
          for (int i = 0; i < limit; i++) {
            q.add(array[1]);
            collection.add(array[1]);
            Check(collection, q, limit, "add", ref, cl);
          }
          collection.clear();
          q.clear();
          Check(collection, q, limit, "clear", ref, cl);
      
          //Recheck add
          for (Object i : array) {
            collection.add(i);
            if (q.size() == limit) {
              q.removeFirst();
            }
            q.add(i);
            Check(collection, q, limit, "add", ref, cl);
          }
      
          return CheckResult.correct();
        }
      }
    learner_created: false
  - name: test/RangeTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.common.ReflectionUtils;
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      
      import java.io.ByteArrayOutputStream;
      import java.io.PrintStream;
      import java.lang.reflect.InvocationTargetException;
      import java.lang.reflect.Method;
      import java.lang.reflect.Modifier;
      import java.util.ArrayList;
      import java.util.HashMap;
      import java.util.List;
      import java.util.Map;
      import java.util.regex.Pattern;
      
      class RangeDelegateSearcher extends DelegateSearcher {
        void Initialize() {
          this.name = "Range";
        }
      
        void Validate() {
          if (original.getTypeParameters().length == 0) {
            throw new WrongAnswer(name + " Class must be a Generic Class.");
          }
          if (!original.getTypeParameters()[0].getBounds()[0].getTypeName().equals("java.lang.Comparable")) {
            throw new WrongAnswer(name + "'s type parameter must extend 'Comparable' interface");
          }
      //    if (!original.getAnnotatedInterfaces()[0].getType().getTypeName().equals("java.io.Serializable")) {
      //      throw new WrongAnswer(name + " Class must implement 'Serializable' interface");
      //    }
      
          for (var c : original.getDeclaredConstructors()) {
            if (Modifier.isPublic(c.getModifiers())) {
              throw new WrongAnswer("None of the " + name + "'s constructors should be public");
            }
          }
      
          //Name, isStatic, returnType, argsType
          CustomMethod[] methods = new CustomMethod[]{
                  new CustomMethod("contains", false, boolean.class, new Class[]{Comparable.class}),
                  new CustomMethod("encloses", false, boolean.class, new Class[]{original}),
                  new CustomMethod("intersection", false, original, new Class[]{original}),
                  new CustomMethod("span", false, original, new Class[]{original}),
                  new CustomMethod("isEmpty", false, boolean.class, new Class[]{}),
                  new CustomMethod("open", true, original, new Class[]{Comparable.class, Comparable.class}),
                  new CustomMethod("closed", true, original, new Class[]{Comparable.class, Comparable.class}),
                  new CustomMethod("openClosed", true, original, new Class[]{Comparable.class, Comparable.class}),
                  new CustomMethod("closedOpen", true, original, new Class[]{Comparable.class, Comparable.class}),
                  new CustomMethod("greaterThan", true, original, new Class[]{Comparable.class}),
                  new CustomMethod("atLeast", true, original, new Class[]{Comparable.class}),
                  new CustomMethod("lessThan", true, original, new Class[]{Comparable.class}),
                  new CustomMethod("atMost", true, original, new Class[]{Comparable.class}),
                  new CustomMethod("all", true, original, new Class[]{}),
          };
      
          for (CustomMethod m : methods) {
            Method method;
            try {
              method = original.getMethod(m.getName(), m.getArgs());
            } catch (NoSuchMethodException e) {
      
              ArrayList<String> names = new ArrayList<>();
              for (Class<?> p : m.getArgs()) {
                if (p.equals(Comparable.class)) {
                  names.add("C");
                } else {
                  names.add(p.getSimpleName());
                }
              }
      
              if (names.isEmpty()) {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method without args is not found");
              } else {
                throw new WrongAnswer(name + "'s " + m.getName() + "() method with args " + names + " is not found");
              }
            }
      
            if (m.isStatic() && !Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be static");
            }
            if (!m.isStatic() && Modifier.isStatic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must not be static");
            }
      
            if (!method.getReturnType().equals(m.getReturnType())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must return " + m.getReturnType().getSimpleName());
            }
      
            if (!Modifier.isPublic(method.getModifiers())) {
              throw new WrongAnswer(name + "'s " + m.getName() + "() method must be public");
            }
          }
        }
      
        @Override
        protected Object invoke(String methodName, Class<?>[] args, Object... objs) {
          try {
            if (objs.length == 0) {
              Method method = original.getMethod(methodName);
              return method.invoke(instance);
            } else {
              Method method = original.getMethod(methodName, args);
              return ReflectionUtils.invokeMethod(method, instance, objs);
            }
          } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | UnexpectedError | StackOverflowError e) {
            if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("NullPointerException")) {
              throw new NullPointerException();
            } else if (e.getCause() != null && e.getCause().getClass().getSimpleName().equals("IllegalArgumentException")) {
              throw new IllegalArgumentException();
            }
      
            throw new WrongAnswer("Could not invoke " + name + "'s " + methodName + "() method correctly or it is throwing " +
                    "wrong exception for a null element or invalid range");
          }
        }
      }
      
      class RangeBridge extends RangeDelegateSearcher {
      
        public boolean contains(Object a) {
          return (boolean) invoke("contains", new Class[]{Comparable.class}, a);
        }
      
        public boolean encloses(Object a) {
          return (boolean) invoke("encloses", new Class[]{original}, a);
        }
      
        public Object intersection(Object a) {
          return invoke("intersection", new Class[]{original}, a);
        }
      
        public Object span(Object a) {
          return invoke("span", new Class[]{original}, a);
        }
      
        public boolean isEmpty() {
          return (boolean) invoke("isEmpty", new Class[]{});
        }
      
        public Object open(Object a, Object b) {
          instance = invoke("open", new Class[]{Comparable.class, Comparable.class}, a, b);
          return instance;
        }
      
        public Object closed(Object a, Object b) {
          instance = invoke("closed", new Class[]{Comparable.class, Comparable.class}, a, b);
          return instance;
        }
      
        public Object openClosed(Object a, Object b) {
          instance = invoke("openClosed", new Class[]{Comparable.class, Comparable.class}, a, b);
          return instance;
        }
      
        public Object closedOpen(Object a, Object b) {
          instance = invoke("closedOpen", new Class[]{Comparable.class, Comparable.class}, a, b);
          return instance;
        }
      
        public Object greaterThan(Object a) {
          instance = invoke("greaterThan", new Class[]{Comparable.class}, a);
          return instance;
        }
      
        public Object atLeast(Object a) {
          instance = invoke("atLeast", new Class[]{Comparable.class}, a);
          return instance;
        }
      
        public Object lessThan(Object a) {
          instance = invoke("lessThan", new Class[]{Comparable.class}, a);
          return instance;
        }
      
        public Object atMost(Object a) {
          instance = invoke("atMost", new Class[]{Comparable.class}, a);
          return instance;
        }
      
        public Object all() {
          instance = invoke("all", new Class[]{});
          return instance;
        }
      
      
        public String toString() {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          PrintStream ps = new PrintStream(baos);
          PrintStream old = System.out;
          System.setOut(ps);
      
          try {
            System.out.print(instance);
          } catch (Throwable e) {
            throw new WrongAnswer("Unexpected " + e.getClass().getSimpleName() + " while parsing output from " +
                    "Range's toString()");
          }
      
          System.out.flush();
          System.setOut(old);
          return baos.toString();
        }
      }
      
      public class RangeTests extends StageTest {
      
        Pattern pattern = Pattern.compile("EMPTY|(\\(|\\[)((.+)|(-INF)), ((.+)|(INF))(\\)|\\])");
      
        enum Type {
          OPEN("open"),
          CLOSED("closed"),
          OPENCLOSED("openClosed"),
          CLOSEDOPEN("closedOpen"),
          LESSTHAN("lessThan"),
          GREATERTHAN("greaterThan"),
          ATLEAST("atLeast"),
          ATMOST("atMost"),
          ALL("all");
      
          String label;
      
          Type(String label) {
            this.label = label;
          }
        }
      
        Object[][] correct_data = {
                {5, 15}, {10, 20}, {15, 25},
                {'e', 'o'}, {'j', 't'}, {'o', 'y'},
                {"EE", "OO"}, {"JJ", "TT"}, {"OO", "YY"}
        };
      
        @DynamicTest(data = "correct_data", order = 0)
        CheckResult test_ex_1(Object a, Object b) {
          boolean c = false;
          // NPE for fabrics Type.OPEN, Type.CLOSED, Type.CLOSEDOPEN, Type.OPENCLOSED
          for (Type type : new Type[]{Type.OPEN, Type.CLOSED, Type.CLOSEDOPEN, Type.OPENCLOSED}) {
            for (boolean lower : new boolean[]{true, false}) {
              c = false;
              try {
                RangeBridge coll = new RangeBridge();
                if (lower) {
                  switch (type) {
                    case OPEN -> coll.open(null, a);
                    case CLOSED -> coll.closed(null, a);
                    case OPENCLOSED -> coll.openClosed(null, a);
                    case CLOSEDOPEN -> coll.closedOpen(null, a);
                  }
                } else {
                  switch (type) {
                    case OPEN -> coll.open(a, null);
                    case CLOSED -> coll.closed(a, null);
                    case OPENCLOSED -> coll.openClosed(a, null);
                    case CLOSEDOPEN -> coll.closedOpen(a, null);
                  }
                }
      
              } catch (NullPointerException e) {
                c = true;
              }
              if (!c) {
                return CheckResult.wrong("Range's " + type.label + "() method should throw a NullPointerException if " +
                        "any of provided arguments is equal to 'null'");
              }
            }
          }
          // NPE for fabrics Type.LESSTHAN, Type.GREATERTHAN, Type.ATLEAST, Type.ATMOST
          for (Type type : new Type[]{Type.LESSTHAN, Type.GREATERTHAN, Type.ATLEAST, Type.ATMOST}) {
            c = false;
            try {
              RangeBridge coll = new RangeBridge();
              switch (type) {
                case LESSTHAN -> coll.lessThan(null);
                case GREATERTHAN -> coll.greaterThan(null);
                case ATLEAST -> coll.atLeast(null);
                case ATMOST -> coll.atMost(null);
              }
            } catch (NullPointerException e) {
              c = true;
            }
            if (!c) {
              return CheckResult.wrong("Range's " + type.label + "() method should throw a NullPointerException if " +
                      "provided argument is equal to 'null'");
            }
          }
      
          for (Type type : new Type[]{Type.OPEN, Type.CLOSED, Type.CLOSEDOPEN, Type.OPENCLOSED}) {
            c = false;
            try {
              RangeBridge coll = new RangeBridge();
              switch (type) {
                case OPEN -> coll.open(a, b);
                case CLOSED -> coll.closed(a, b);
                case OPENCLOSED -> coll.openClosed(a, b);
                case CLOSEDOPEN -> coll.closedOpen(a, b);
              }
      
            } catch (NullPointerException e) {
              c = true;
            }
            if (c) {
              return CheckResult.wrong("Range's " + type.label + "() method should not throw a NullPointerException if " +
                      "none of provided arguments is equal to 'null'");
            }
          }
      
          for (Type type : new Type[]{Type.LESSTHAN, Type.GREATERTHAN, Type.ATLEAST, Type.ATMOST}) {
            c = false;
            try {
              RangeBridge coll = new RangeBridge();
              switch (type) {
                case LESSTHAN -> coll.lessThan(a);
                case GREATERTHAN -> coll.greaterThan(a);
                case ATLEAST -> coll.atLeast(a);
                case ATMOST -> coll.atMost(a);
              }
            } catch (NullPointerException e) {
              c = true;
            }
            if (c) {
              return CheckResult.wrong("Range's " + type.label + "() method should not throw a NullPointerException if " +
                      "provided argument is not 'null'");
            }
          }
          // NPE for methods
          for (Type type : Type.values()) {
            c = false;
            RangeBridge coll = new RangeBridge();
            try {
              switch (type) {
                case OPEN -> coll.open(a, b);
                case CLOSED -> coll.closed(a, b);
                case OPENCLOSED -> coll.openClosed(a, b);
                case CLOSEDOPEN -> coll.closedOpen(a, b);
                case LESSTHAN -> coll.lessThan(a);
                case GREATERTHAN -> coll.greaterThan(a);
                case ATLEAST -> coll.atLeast(a);
                case ATMOST -> coll.atMost(a);
                case ALL -> coll.all();
              }
            } catch (NullPointerException | IllegalArgumentException e) {
              return CheckResult.wrong("Range's fabric " + type.label + "() method should not throw any exceptions if " +
                      "all provided arguments are valid. Caught: "+e.getClass().getSimpleName());
            }
            for (String method : new String[]{"contains", "encloses", "intersection", "span"}) {
              try {
                switch (method) {
                  case "contains" -> coll.contains(null);
                  case "encloses" -> coll.encloses(null);
                  case "intersection" -> coll.intersection(null);
                  case "span" -> coll.span(null);
                }
              } catch (NullPointerException e) {
                c = true;
              }
              if (!c) {
                return CheckResult.wrong("Range's " + method + "() method should throw a NullPointerException if " +
                        "provided argument is equal to 'null'");
              }
            }
          }
          return CheckResult.correct();
        }
      
        Object[][] data_ex_2 = {
                {5}, {10}, {15},
                {'e'}, {'j'}, {'a'},
                {"HELLO"}, {"WORLD"}, {"!"}
        };
      
        @DynamicTest(data = "data_ex_2", order = 1)
        CheckResult test_ex_2(Object a) {
          boolean c = false;
          // Open, lowerBound == upperBound
          try {
            RangeBridge coll = new RangeBridge();
            coll.open(a, a);
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("Range's open() method should throw an IllegalArgumentException if " +
                    "provided LowerBound is equal UpperBound");
          }
          for (Type type : new Type[]{Type.CLOSED, Type.CLOSEDOPEN, Type.OPENCLOSED}) {
            c = false;
            try {
              RangeBridge coll = new RangeBridge();
              switch (type) {
                case CLOSED -> coll.closed(a, a);
                case OPENCLOSED -> coll.openClosed(a, a);
                case CLOSEDOPEN -> coll.closedOpen(a, a);
              }
            } catch (IllegalArgumentException e) {
              c = true;
            }
            if (c) {
              return CheckResult.wrong("Range's " + type.label + "() method should not throw an IllegalArgumentException if" +
                      " provided LowerBound is equal UpperBound");
            }
          }
          return CheckResult.correct();
        }
      
        Object[][] data_ex_3 = {
                {Type.OPEN, 5, 10}, {Type.CLOSED, 5, 10}, {Type.OPENCLOSED, 5, 10}, {Type.CLOSEDOPEN, 5, 10},
      
                {Type.OPEN, 'e', 'j'}, {Type.CLOSED, 'e', 'j'}, {Type.OPENCLOSED, 'e', 'j'}, {Type.CLOSEDOPEN, 'e', 'j'},
      
                {Type.OPEN, "HELLO", "WORLD"}, {Type.CLOSED, "HELLO", "WORLD"}, {Type.OPENCLOSED, "HELLO", "WORLD"},
                {Type.CLOSEDOPEN, "HELLO", "WORLD"}
        };
      
        @DynamicTest(data = "data_ex_3", order = 2)
        CheckResult test_ex_3(Type type, Object a, Object b) {
          boolean c = false;
          // LowerBound greater than upperBound
          try {
            RangeBridge coll = new RangeBridge();
            switch (type) {
              case OPEN -> coll.open(b, a);
              case CLOSED -> coll.closed(b, a);
              case OPENCLOSED -> coll.openClosed(b, a);
              case CLOSEDOPEN -> coll.closedOpen(b, a);
            }
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (!c) {
            return CheckResult.wrong("Range's " + type.label + "() method should throw an IllegalArgumentException if " +
                    "provided LowerBound greater than UpperBound");
          }
          c = false;
          try {
            RangeBridge coll = new RangeBridge();
            switch (type) {
              case OPEN -> coll.open(a, b);
              case CLOSED -> coll.closed(a, b);
              case OPENCLOSED -> coll.openClosed(a, b);
              case CLOSEDOPEN -> coll.closedOpen(a, b);
            }
          } catch (IllegalArgumentException e) {
            c = true;
          }
          if (c) {
            return CheckResult.wrong("Range's " + type.label + "() method should not throw an IllegalArgumentException if " +
                    "provided LowerBound less than UpperBound");
          }
          return CheckResult.correct();
        }
      
      
        void InstanceCheck(RangeBridge coll, ActualRange<Comparable> actual, Comparable[] contains, boolean reveal) {
          String str = coll.toString();
          if (!pattern.matcher(str).matches()) {
            if (reveal)
              throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                      "examples.\n" +
                      "Got: " + str + "\n");
            else
              throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                      "examples");
          }
          if (!str.equals(actual.toString())) {
            if (reveal)
              throw new WrongAnswer("Instance of Range object is not being printed correctly. Printed values or " +
                      "their boundaries do not correspond to those provided\n" +
                      "Expected: " + actual + "\n" +
                      "Got: " + str + "\n");
            else
              throw new WrongAnswer("Instance of Range object is not being printed correctly. Printed values or " +
                      "their boundaries do not correspond to those provided");
          }
          if (coll.isEmpty() != actual.isEmpty()) {
            if (reveal)
              throw new WrongAnswer("Incorrect result from Range's isEmpty() method.\n" +
                      "Case: " + actual + "\n" +
                      "Expected: " + actual.isEmpty() + "\n" +
                      "Got: " + coll.isEmpty() + "\n");
            else
              throw new WrongAnswer("Incorrect result from Range's isEmpty() method.");
          }
          if (contains.length > 0)
            for (Comparable i : contains) {
              if (coll.contains(i) != actual.contains(i)) {
                if (reveal)
                  throw new WrongAnswer("Incorrect result from Range's contains() method.\n" +
                          "Case: " + actual + ", (" + i + ")\n" +
                          "Expected: " + actual.contains(i) + "\n" +
                          "Got: " + coll.contains(i) + "\n");
                else
                  throw new WrongAnswer("Incorrect result from Range's contains() method.");
              }
            }
        }
      
        void CheckEnclosesSpanIntersection(RangeBridge main, Object secondary, ActualRange actualMain,
                                           ActualRange actualSecondary, boolean reveal) {
          String method = "";
          try {
            method = "encloses()";
            boolean enclosesResult = main.encloses(secondary);
            if (enclosesResult != actualMain.encloses(actualSecondary)) {
              if (reveal)
                throw new WrongAnswer("Incorrect result from Range's encloses() method.\n" +
                        "Case: " + actualMain + ", " + actualSecondary + "\n" +
                        "Expected: " + actualMain.encloses(actualSecondary) + "\n" +
                        "Got: " + enclosesResult + "\n");
              else
                throw new WrongAnswer("Incorrect result from Range's encloses() method.");
            }
            method = "span()";
            Object spanResult = main.span(secondary);
            if (!pattern.matcher(spanResult.toString()).matches()) {
              if (reveal)
                throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                        "examples.\n" +
                        "Got: " + spanResult + "\n");
              else
                throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                        "examples");
            }
            if (!spanResult.toString().equals(actualMain.span(actualSecondary).toString())) {
              if (reveal)
                throw new WrongAnswer("Incorrect result from Range's span() method.\n" +
                        "Case: " + actualMain + ", " + actualSecondary + "\n" +
                        "Expected: " + actualMain.span(actualSecondary) + "\n" +
                        "Got: " + spanResult + "\n");
              else
                throw new WrongAnswer("Incorrect result from Range's span() method.");
            }
            method = "intersection()";
            Object intersectionResult = main.intersection(secondary);
            if (!pattern.matcher(intersectionResult.toString()).matches()) {
              if (reveal)
                throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                        "examples.\n" +
                        "Got: " + intersectionResult + "\n");
              else
                throw new WrongAnswer("Instance of Range object is not being printed correctly, check out the " +
                        "examples");
            }
            if (!intersectionResult.toString().equals(actualMain.intersection(actualSecondary).toString())) {
              if (reveal)
                throw new WrongAnswer("Incorrect result from Range's intersection() method.\n" +
                        "Case: " + actualMain + ", " + actualSecondary + "\n" +
                        "Expected: " + actualMain.intersection(actualSecondary) + "\n" +
                        "Got: " + intersectionResult + "\n");
              else
                throw new WrongAnswer("Incorrect result from Range's intersection() method.");
            }
          } catch (NullPointerException | IllegalArgumentException | IllegalStateException e) {
            throw new WrongAnswer("Incorrect result from Range's " + method + " method.\n" +
                    "Got: " + e.getClass().getSimpleName() + "\n");
          }
        }
      
        //data, contains, nContains
        Object contains_empty_data() {
          Comparable[][] beta = new Comparable[][]{
                  {5, 10, 15, 20, 25},
                  {'e', 'j', 'o', 't', 'y'},
                  {"e", "j", "o", "t", "y"}
          };
          List<Object[]> result = new ArrayList<>();
          for (Comparable[] i : beta) {
            Map<ActualRange, Type> data = new HashMap<>();
            for (int j = 0; j < 3; j++) {
              data.put(ActualRange.open(i[j], i[j + 2]), Type.OPEN);
              data.put(ActualRange.closed(i[j], i[j + 2]), Type.CLOSED);
              data.put(ActualRange.openClosed(i[j], i[j + 2]), Type.OPENCLOSED);
              data.put(ActualRange.closedOpen(i[j], i[j + 2]), Type.CLOSEDOPEN);
            }
            for (Comparable j : i) {
              data.put(ActualRange.closed(j, j), Type.CLOSED);
              data.put(ActualRange.openClosed(j, j), Type.OPENCLOSED);
              data.put(ActualRange.closedOpen(j, j), Type.CLOSEDOPEN);
              data.put(ActualRange.lessThan(j), Type.LESSTHAN);
              data.put(ActualRange.atMost(j), Type.ATMOST);
              data.put(ActualRange.greaterThan(j), Type.GREATERTHAN);
              data.put(ActualRange.atLeast(j), Type.ATLEAST);
            }
            data.put(ActualRange.all(), Type.ALL);
            result.add(new Object[]{data});
          }
          return result.toArray();
        }
      
        @DynamicTest(order = 3, data = "contains_empty_data")
        CheckResult test_contains_empty(Map<ActualRange, Type> m) {
          for (Map.Entry<ActualRange, Type> entry : m.entrySet()) {
            RangeBridge coll = new RangeBridge();
            Type type = entry.getValue();
            ActualRange data = entry.getKey();
            switch (type) {
              case OPEN -> coll.open(data.getLowerBound(), data.getUpperBound());
              case CLOSED -> coll.closed(data.getLowerBound(), data.getUpperBound());
              case OPENCLOSED -> coll.openClosed(data.getLowerBound(), data.getUpperBound());
              case CLOSEDOPEN -> coll.closedOpen(data.getLowerBound(), data.getUpperBound());
              case LESSTHAN -> coll.lessThan(data.getUpperBound());
              case GREATERTHAN -> coll.greaterThan(data.getLowerBound());
              case ATLEAST -> coll.atLeast(data.getLowerBound());
              case ATMOST -> coll.atMost(data.getUpperBound());
              case ALL -> coll.all();
            }
      
            switch (data.getClass().getSimpleName()) {
              case "Integer":
                InstanceCheck(coll, data, new Comparable[]{0, 5, 10, 15, 20, 25, 30}, true);
              case "Character":
                InstanceCheck(coll, data, new Comparable[]{'a', 'e', 'j', 'o', 't', 'y', 'z'}, false);
              case "String":
                InstanceCheck(coll, data, new Comparable[]{"a", "e", "j", "o", "t", "y", "z"}, false);
            }
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 4, data = "contains_empty_data")
        CheckResult test_actions(Map<ActualRange, Type> m) {
          for (Map.Entry<ActualRange, Type> entry1 : m.entrySet()) {
            RangeBridge coll1 = new RangeBridge();
            Type type = entry1.getValue();
            ActualRange data = entry1.getKey();
            switch (type) {
              case OPEN -> coll1.open(data.getLowerBound(), data.getUpperBound());
              case CLOSED -> coll1.closed(data.getLowerBound(), data.getUpperBound());
              case OPENCLOSED -> coll1.openClosed(data.getLowerBound(), data.getUpperBound());
              case CLOSEDOPEN -> coll1.closedOpen(data.getLowerBound(), data.getUpperBound());
              case LESSTHAN -> coll1.lessThan(data.getUpperBound());
              case GREATERTHAN -> coll1.greaterThan(data.getLowerBound());
              case ATLEAST -> coll1.atLeast(data.getLowerBound());
              case ATMOST -> coll1.atMost(data.getUpperBound());
              case ALL -> coll1.all();
            }
            for (Map.Entry<ActualRange, Type> entry2 : m.entrySet()) {
              RangeBridge coll2 = new RangeBridge();
              Type type2 = entry2.getValue();
              ActualRange data2 = entry2.getKey();
              switch (type2) {
                case OPEN -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.open(data2.getLowerBound(), data2.getUpperBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case CLOSED -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.closed(data2.getLowerBound(), data2.getUpperBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case OPENCLOSED -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.openClosed(data2.getLowerBound(), data2.getUpperBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case CLOSEDOPEN -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.closedOpen(data2.getLowerBound(), data2.getUpperBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case LESSTHAN -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.lessThan(data2.getUpperBound()),
                        data, data2, data2.getUpperBound().getClass().getSimpleName().equals("Integer"));
                case GREATERTHAN -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.greaterThan(data2.getLowerBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case ATLEAST -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.atLeast(data2.getLowerBound()),
                        data, data2, data2.getLowerBound().getClass().getSimpleName().equals("Integer"));
                case ATMOST -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.atMost(data2.getUpperBound()),
                        data, data2, data2.getUpperBound().getClass().getSimpleName().equals("Integer"));
                case ALL -> CheckEnclosesSpanIntersection(
                        coll1,
                        coll2.all(),
                        data, data2, false);
              }
            }
          }
          return CheckResult.correct();
        }
      }
    learner_created: false
  - name: src/collections/BiMap.java
    visible: true
    text: |
      package collections;
      
      import java.util.*;
      
      public class BiMap <K, V> {
          private final Map<K, V> map = new HashMap<>();
      
          public V put(K key, V value) {
              if (map.containsKey(key) || map.containsValue(value)) {
                  throw new IllegalArgumentException();
              }
              return map.put(key, value);
          }
      
          public void putAll(Map<K, V> map) {
              for (K key : map.keySet()) {
                  put(key, map.get(key));
              }
          }
      
          public Set<V> values() {
              return new HashSet<>(map.values());
          }
      
          public V forcePut(K key, V value) {
              List<K> removeKey = new ArrayList<>();
              for (K k : map.keySet()) {
                  if (Objects.equals(k, key) || Objects.equals(value, map.get(k))) {
                      removeKey.add(k);
                  }
              }
              for (K k : removeKey) {
                  map.remove(k);
              }
              return map.put(key, value);
          }
      
          public BiMap<V, K> inverse() {
              BiMap<V, K> inverse = new BiMap<>();
              for (K key: map.keySet()) {
                  inverse.forcePut(map.get(key), key);
              }
              return inverse;
          }
      
          @Override
          public String toString() {
              return map.toString();
          }
      
      }
    learner_created: true
  - name: src/collections/Multiset.java
    visible: true
    text: |
      package collections;
      
      import java.util.*;
      
      public class Multiset <E> {
          private final List<E> list = new ArrayList<>();
      
          /**
           * Adds a single occurrence of the specified element to the current multiset
           * @param element E element
           */
          public void add(E element) {
              this.list.add(element);
          }
      
          /**
           * Adds a number of occurrences of an element to the current multiset
           * @param element E element
           * @param occurrences number of occurrences
           */
          public void add(E element, int occurrences) {
              if (occurrences <= 0) {
                  return;
              }
              while (occurrences > 0) {
                  list.add(element);
                  occurrences -= 1;
              }
          }
      
          /**
           * Determines whether the current multiset contains the specified element
           * @param element E element
           * @return true if the list contains element, otherwise else
           */
          public boolean contains(E element) {
              return list.contains(element);
          }
      
          /**
           * Returns the number of occurrences of an element in the current multiset (the count of the element)
           * @param element E element
           * @return number of occurrences of element
           */
          public int count(E element) {
              int count = 0;
              for (E e : list) {
                  if (Objects.equals(e, element)) {
                      count += 1;
                  }
              }
              return count;
          }
      
          /**
           * Returns the set of distinct elements contained in the current multiset
           * @return set of distinct elements
           */
          public Set<E> elementSet() {
              return new HashSet<>(list);
          }
      
          /**
           * Removes a single occurrence of the specified element from the current multiset, if present
           * @param element remove element
           */
          public void remove(E element) {
              list.remove(element);
          }
      
          /**
           * Removes a number of occurrences of the specified element from the current multiset
           * @param element remove element
           * @param occurrences a number of occurrences
           */
          public void remove(E element, int occurrences) {
              while (occurrences > 0) {
                  list.remove(element);
                  occurrences -= 1;
              }
          }
      
          /**
           * Adds or removes the necessary occurrences of an element so that the element attains the desired count.
           * If there are no occurences, multiset's elements should not change.
           * @param element check element
           * @param count desired count
           */
          public void setCount(E element, int count) {
              if (count < 0) {
                  return;
              }
              int currentOccurrences = count(element);
              if (currentOccurrences == 0) {
                  return;
              }
              if (currentOccurrences > count) {
                  remove(element, currentOccurrences - count);
              } else if (currentOccurrences < count) {
                  int lastIndex = list.lastIndexOf(element);
                  while (currentOccurrences < count) {
                      list.add(lastIndex, element);
                      currentOccurrences += 1;
                  }
              }
          }
      
          /**
           * Conditionally sets the count of an element to a new value, as described in setCount(E element, int count),
           * provided that the element has the expected current count. If there are no occurences, multiset's elements should not change.
           * @param element element
           * @param oldCount old count
           * @param newCount new count
           */
          public void setCount(E element, int oldCount, int newCount) {
              int curCount = count(element);
              if (curCount == 0) {
                  return;
              }
              if (curCount == oldCount) {
                  setCount(element, newCount);
              }
          }
      
          @Override
          public String toString() {
              return list.toString();
          }
      
          public static void main(String[] args) {
              Multiset<Character> multiset = new Multiset<>();
              multiset.add('a');
              multiset.add('b', 6);
      
              System.out.println(multiset); // [a, b, b, b, b, b, b]
              System.out.println(multiset.contains('c')); // false
              System.out.println(multiset.count('b')); // 6
              System.out.println(multiset.elementSet()); // ['a', 'b']
      
              multiset.remove('a');
              multiset.remove('b', 3);
      
              System.out.println(multiset); // [b, b, b]
      
              multiset.add('c');
              multiset.setCount('c', 2);
              multiset.setCount('b', 3, 4);
      
              System.out.println(multiset); // [b, b, b, b, c, c]
          }
      }
    learner_created: true
  - name: src/collections/SizeLimitedQueue.java
    visible: true
    text: |
      package collections;
      
      import java.util.*;
      
      public class SizeLimitedQueue<E> {
          private final int maxSize;
          private final Queue<E> queue = new ArrayDeque<>();
      
          public SizeLimitedQueue(int maxSize) {
              if (maxSize <= 0) {
                  throw new IllegalArgumentException("Maximum size must be positive");
              }
              this.maxSize = maxSize;
          }
      
          public void add(E element) {
              if (queue.size() == maxSize) {
                  queue.poll();
              }
              queue.add(element);
          }
      
          public void clear() {
              queue.clear();
          }
      
          public boolean isAtFullCapacity() {
              return queue.size() == maxSize;
          }
      
          public boolean isEmpty() {
              return queue.isEmpty();
          }
      
          public int maxSize() {
              return maxSize;
          }
      
          public E peek() {
              return queue.peek();
          }
      
          public E remove() {
              if (isEmpty()) {
                  throw new NoSuchElementException("Queue is empty");
              }
              return queue.remove();
          }
      
          public int size() {
              return queue.size();
          }
      
          public E[] toArray(E[] e) {
              return queue.toArray(e);
          }
      
          public Object[] toArray() {
              return queue.toArray();
          }
      
          @Override
          public String toString() {
              return queue.stream().toList().toString();
          }
      }
    learner_created: true
  - name: src/collections/ImmutableCollection.java
    visible: true
    text: |
      package collections;
      
      import java.util.*;
      import java.util.function.Consumer;
      
      public final class ImmutableCollection <E> implements Iterable<E> {
      
          List<E> items = new ArrayList<>();
      
          private ImmutableCollection() { }
      
          public static <T> ImmutableCollection<T> of() {
              return new ImmutableCollection<T>();
          }
      
          public static <E> ImmutableCollection<E> of(E... elements) {
              ImmutableCollection<E> collection = new ImmutableCollection<>();
              for (E element : elements) {
                  if (element == null) {
                      throw  new NullPointerException();
                  }
                  collection.items.add(element);
              }
              return collection;
          }
      
          public boolean isEmpty() {
              return items.isEmpty();
          }
      
          public int size() {
              return items.size();
          }
      
          public boolean contains(E element) {
              return items.contains(element);
          }
      
          @Override
          public Iterator<E> iterator() {
              return null;
          }
      
          @Override
          public void forEach(Consumer<? super E> action) {
              Iterable.super.forEach(action);
          }
      
          @Override
          public Spliterator<E> spliterator() {
              return Iterable.super.spliterator();
          }
      }
    learner_created: true
feedback_link: https://hyperskill.org/projects/319/stages/1792/implement#comment
status: Unchecked
record: -1
